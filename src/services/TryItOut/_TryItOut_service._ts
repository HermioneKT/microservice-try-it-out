/* eslint-disable @typescript-eslint/restrict-template-expressions */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-floating-promises */

import { ref, Ref } from 'vue';
import {
  inputPropertyInterface,
  docInterface,
  inputPropertiesInterface,
} from './TryItOut_types';
// import yaml from 'yamljs';

/** DO NOT mutate or change this rawDocRef */
const rawDocRef = ref();

/** Any user input or update goes to  here */
const userDocRef = ref();

const apiResponse = ref();

const apiKey = ref(localStorage.getItem('sentientApiKey') || '');

const tryItOutService = () => {
  function setApiKey() {
    localStorage.setItem('sentientApiKey', apiKey.value);
  }

  function updateJsonToInputProperties(
    jsonStr: string,
    inputProperties: inputPropertiesInterface
  ) {
    let parsedStr = '';
    try {
      parsedStr = JSON.parse(reverseFormatJsonString(jsonStr));
    } catch (err) {
      console.log(err);
      throw err; // For bad formatted jsong string
    }
    Object.keys(parsedStr).forEach((key) => {
      /**
       * From inputProperties find the x-name value equals to Json
       * input key, then update input value to example.
       */
      if (checkPropertyKeyExistance(inputProperties, key)) {
        const propertyToUpdate =
          inputProperties[key] ??
          Object.values(inputProperties).find((property) => {
            const theKey = property['x-name'] ?? property.name;
            return theKey === key;
          });
        propertyToUpdate.example = parsedStr[key];
      } else {
        throw `
          Fields "${key}" doesn't belong to the input data schemas. 
          Please double check the spelling. 
          Alternately, you can use the Fields Input mode for a more user friendly experience.`;
      }
    });
    updateUserDeletedInputProperty(parsedStr, inputProperties);
    return inputProperties;
  }

  function checkPropertyKeyExistance(
    inputProperties: inputPropertiesInterface,
    keyToCheck: string
  ) {
    let keyExist = false;
    Object.keys(inputProperties).forEach((key) => {
      const propertyKey =
        inputProperties[key]['x-name'] ?? inputProperties[key].name ?? key;
      if (propertyKey === keyToCheck) {
        keyExist = true;
      }
    });
    return keyExist;
  }

  function updateUserDeletedInputProperty(
    newInputProps: inputPropertyInterface,
    currentInputProps: inputPropertiesInterface
  ) {
    Object.keys(currentInputProps).forEach((key) => {
      const currentKey =
        currentInputProps[key]['x-name'] ?? currentInputProps[key].name ?? key;
      if (!checkPropertyKeyExistance(newInputProps, currentKey)) {
        const currentProp = currentInputProps[currentKey];
        currentProp.example = '';
        checkRequiredValue(currentProp, listOfRequiredValues(rawDocRef.value));
      }
    });
  }

  function validateInputProperties(
    inputProperties = getInputProperties(userDocRef)
  ) {
    try {
      Object.keys(inputProperties).forEach((propertyKey) => {
        const property = inputProperties[propertyKey];
        checkRequiredValue({ [propertyKey]: property });
      });
    } catch (err) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      return err;
    }
    return '';
  }

  function checkRequiredValue(
    property = getInputProperties(userDocRef) /* Object */,
    requiredValues = listOfRequiredValues(userDocRef) /* List */
  ) {
    const propertyKey: string =
      property['x-name'] ?? property.name ?? Object.keys(property)[0];
    if (
      requiredValues.includes(propertyKey) &&
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      !property[propertyKey.toString()].example
    ) {
      throw `Fields "${propertyKey}" is required with valid value.`;
    }
    return true;
  }

  function listOfRequiredValues(apiDocRef: Ref<docInterface>): [] {
    const apiDoc = apiDocRef.value ?? apiDocRef;
    return apiDoc?.components?.schemas?.input?.required || [];
  }

  function fetchApiDoc(path) {
    // const doc = yaml.load(path);
    // !important: Temp disable yaml library, due to fs not supported issue
    const doc = '';
    console.log(path);
    rawDocRef.value = doc;
    initUserDocRef();
  }

  function initUserDocRef() {
    /** Duplicate and remove the reactivity of doc object */
    userDocRef.value = JSON.parse(JSON.stringify(rawDocRef.value));
    apiResponse.value = '';
  }

  function validApiDoc(apiDoc: docInterface): boolean {
    let valid = true;
    if (!apiDoc.paths) {
      valid = false;
    }
    return valid;
  }

  function inputTypeByApi(apiDoc: docInterface) {
    let inputType = 'jsonDataInput';
    let apiType;
    if (validApiDoc(apiDoc)) {
      apiType = Object.keys(Object.values(apiDoc.paths)[0])[0];
    }
    if (apiType === 'get') {
      inputType = 'queryStringInput';
    }
    return inputType;
  }

  function getInputProperties(
    apiDocRef: Ref<docInterface>
  ): inputPropertiesInterface {
    const apiDoc = apiDocRef.value ?? apiDocRef;
    let inputProperties = {};
    try {
      inputProperties = JSON.parse(apiDoc.components.schemas.input.properties);
      addMaskedValueToInputProperties(inputProperties);
    } catch (err) {}
    try {
      inputProperties = Object.values(apiDoc.paths)[0].get.parameters;
    } catch (err) {}
    return inputProperties;
  }

  function addMaskedValueToInputProperties(
    inputProperties: inputPropertiesInterface
  ) {
    const trim = 5000;
    Object.values(inputProperties).forEach(
      (property: inputPropertyInterface) => {
        if (property.example.toString().length > trim) {
          property.maskedValue =
            property.example.toString().slice(0, trim) +
            `...(${
              property.example.toString().length - trim
            } characters been clipped)`;
        }
      }
    );
  }

  function inputPropertiesToJsonString(
    inputProperties: inputPropertiesInterface
  ) {
    const jsonInput = {};
    Object.keys(inputProperties).forEach((propertyKey) => {
      const property = inputProperties[propertyKey];
      const key = property.name || property['x-name'] || propertyKey;
      // !debugging
      const value = property.maskedValue || property.example;

      // if (value?.name && value?.size && value?.type) {
      //   value = value.name;
      // }
      Object.assign(jsonInput, {
        [key]: value,
      });
    });
    return JSON.stringify(jsonInput);
  }

  // function rawInputPropertiesToJsonString(
  //   inputProperties: inputPropertyInterface
  // ) {
  //   /** Ignores masked value and empty value */
  //   const jsonInput = {};
  //   Object.keys(inputProperties).forEach((propertyKey) => {
  //     const property: inputPropertyInterface = inputProperties[propertyKey];
  //     const key = property.name || property['x-name'] || propertyKey;
  //     const value = property.example;
  //     if (value) {
  //       Object.assign(jsonInput, {
  //         [key]: modifyValueByType(value.toString(), property.type),
  //       });
  //     }
  //   });
  //   return JSON.stringify(jsonInput);
  // }

  // function modifyValueByType(value: string, type: string) {
  //   let modifiedValue = value;
  //   switch (type) {
  //     case 'array':
  //       console.log(value);
  //       typeof value !== 'object' ? (modifiedValue = JSON.parse(value)) : null;
  //       break;

  //     default:
  //       break;
  //   }
  //   return modifiedValue;
  // }

  function inputPropertiesContainMaskedValue(
    inputProperties: inputPropertiesInterface
  ) {
    let hasMaskedValue = false;
    Object.values(inputProperties).forEach((property) => {
      if (property.maskedValue) {
        hasMaskedValue = true;
      }
    });
    return hasMaskedValue;
  }

  function inputPropertiesContainBinaryFile(
    inputProperties: inputPropertyInterface
  ) {
    let hasBinaryFile = false;
    Object.values(inputProperties).forEach((property) => {
      if (
        property.example.name &&
        property.example.size &&
        property.example.type
      ) {
        hasBinaryFile = true;
      }
    });
    return hasBinaryFile;
  }

  function formatJsonString(jsonString: string, removeEmptyValue = false) {
    const splittedJsonStr = splitJsonStringIntoLines(jsonString);
    const tempArr = splittedJsonStr.split('\n');
    let formattedStr = '';
    let indent = '';
    tempArr.forEach((str) => {
      str.includes('}') ? (indent = indent.replace('    ', '')) : null;
      formattedStr += indent + str + '\n';
      str.includes('{') ? (indent += '    ') : null;
    });

    if (removeEmptyValue) {
      /** Remove empty value */
      formattedStr = formattedStr.replace(/".+":""(,\n)?/g, '');
    }

    formattedStr = formattedStr
      .replace(/\\\"/g, '"')
      .replace(/\"\{/g, '{')
      .replace(/\}\"/g, '}');
    return formattedStr;
  }

  function reverseFormatJsonString(jsonString: string) {
    return jsonString.replace(/\n/g, '');
  }

  function splitJsonStringIntoLines(jsonString: string) {
    const formattedStr = jsonString
      .replace(/\{/g, '{\n') // Move all start "{" to next line
      .replace(/\}/g, '\n}') // Move all end "{" to next line
      .replace(/\,\"/g, ',\n"') // Move all string after comma ',' to new line
      .replace(/,\s*\n\}/g, '\n}');
    return formattedStr;
  }

  function editingHeavyContentAlert() {
    window.alert(
      `It seems you are dealing with huge amount of data.\
Please take note this page is for demo and explore puspe only.\ 
To edit the content, please use provided media/file uploader under \ 
Fields Input mode to update data instead of directly editing here.`
    );
  }

  function editingBinaryFileContentAlert() {
    window.alert(
      `This JSON format data contains uploaded binary file, eidting on this page may cause data format error.
Please edit with Fields Input mode instead.`
    );
  }

  function getInputFieldLabel(
    inputProperty: inputPropertyInterface,
    idx: number | string
  ) {
    /**
     * idx is a fall back, some case the property doesn't
     * contain x-name and name, but the key itself is the name
     */
    let label = '';
    label = inputProperty['x-name'] || inputProperty.name || idx.toString();
    label += ` (${inputProperty.type || inputProperty.schema.type})`;
    return label;
  }

  function checkJsonAlikeString(str: string) {
    const jsonValidator =
      /[{\[]{1}([,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]|".*?")+[}\]]{1}/;
    return jsonValidator.test(str);
  }

  function parseInputPropertiesToQueryStr(
    inputPropertiesRef: inputPropertiesInterface
  ) {
    let queryStr = '';

    if (!inputPropertiesRef) {
      return queryStr;
    }
    // Added object.values to avoid type error, temp solution
    Object.values(inputPropertiesRef).forEach(
      (property: inputPropertyInterface) => {
        if (property.example) {
          queryStr += `${property.name}=${property.example}&`;
        }
      }
    );

    queryStr = queryStr.replace(/\\\"/g, '"');
    queryStr = `?${encodeURI(queryStr)}`;
    queryStr = queryStr.replace(/\&$/, '');
    return queryStr;
  }

  function getApiCallMethod(docRef: Ref<docInterface>) {
    const doc = docRef.value ?? docRef;
    const method = Object.keys(Object.values(doc.paths)[0])[0];
    return method;
  }

  function getEndPoint(docRef: Ref<docInterface>) {
    const doc = docRef.value ?? docRef;
    const server: string = doc.servers[0]['url'];
    const path = Object.keys(doc.paths)[0];
    return `${server}${path}`;
  }

  function getContentType(docRef: Ref<docInterface>) {
    const doc = docRef.value ?? docRef;
    console.log(doc);

    // !Debugging
    const contentType = '';
    // const contentType = Object.keys(
    //   // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    //   Object.values(Object.values(doc.paths)[0])[0].requestBody.content
    // )[0];
    return contentType;
  }

  function makePostApiCall() {
    return new Promise((resolve) => {
      const xhr = new XMLHttpRequest();
      xhr.open('POST', getEndPoint(userDocRef));

      xhr.onreadystatechange = function () {
        if (this.readyState === this.DONE) {
          apiResponse.value = xhr;
          console.log(xhr);
          resolve(xhr.response);
        }
      };
      xhr.setRequestHeader('Content-Type', getContentType(userDocRef));
      xhr.setRequestHeader('x-api-key', apiKey.value);
      // !Debugging
      // xhr.send(rawInputPropertiesToJsonString(getInputProperties(userDocRef)));
      // !Debugging
      xhr.send('');
    });
  }

  function makeGetApiCall() {
    return new Promise((resolve) => {
      const xhr = new XMLHttpRequest();
      xhr.open(
        'GET',
        getEndPoint(userDocRef) +
          parseInputPropertiesToQueryStr(getInputProperties(userDocRef))
      );

      xhr.onreadystatechange = function () {
        if (this.readyState === this.DONE) {
          apiResponse.value = xhr;
          console.log(xhr);
          resolve(xhr.response);
        }
      };
      xhr.setRequestHeader('x-api-key', apiKey.value);
      xhr.send(null);
    });
  }

  function checkAudioBase64String(base64String: string) {
    if (typeof base64String == 'string' && base64String.includes('UklGR')) {
      return true;
    }
    return false;
  }

  function getInputDataType(inputProperty: inputPropertyInterface) {
    switch (inputProperty.type) {
      case 'float':
        return 'number';
        break;
      default:
        return 'textarea';
        break;
    }
  }

  function updateInputPropertyExampleValue(
    inputProperty: inputPropertyInterface,
    exampleValue: string
  ) {
    console.log(exampleValue);
    try {
      switch (inputProperty.type) {
        case 'float':
          inputProperty.example = parseFloat(exampleValue);
          break;

        default:
          inputProperty.example = exampleValue;
          break;
      }
    } catch (error) {
      console.log(error);
    }
  }

  return {
    fetchApiDoc,
    initUserDocRef,
    inputTypeByApi,

    validApiDoc,
    validateInputProperties,
    checkRequiredValue,
    checkJsonAlikeString,
    checkAudioBase64String,

    setApiKey,
    addMaskedValueToInputProperties,

    getInputProperties,
    getApiCallMethod,
    getInputFieldLabel,
    getEndPoint,
    getInputDataType,

    inputPropertiesToJsonString,
    inputPropertiesContainMaskedValue,
    inputPropertiesContainBinaryFile,
    parseInputPropertiesToQueryStr,
    formatJsonString,

    updateJsonToInputProperties,
    updateInputPropertyExampleValue,

    listOfRequiredValues,

    editingHeavyContentAlert,
    editingBinaryFileContentAlert,

    makePostApiCall,
    makeGetApiCall,
    apiKey,
    rawDocRef,
    userDocRef,
    apiResponse,
  };
};

export { tryItOutService };
